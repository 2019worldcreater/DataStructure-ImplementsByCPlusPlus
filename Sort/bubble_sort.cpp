//
// Created by HP on 2020-12-1.
//

#include "declaration/bubble_sort.h"

//冒泡排序,比较次数比直接交换排序少，但交换次数比直接交换排序多  稳定
void bubble_sort(int *a, int n) {
    /*
     * 在交换排序过程中，可能会存在小元素移动到大元素后面去，比如 [2]=3, [8]=2,这时交换2,8, 3交换到一些大元素后面
     * 这无疑为之后的排序增加了些许烦恼
     *
     * 如果我们能保证每次交换都只是让元素朝着其应该的方向前进，哪怕一点
     *
     * 冒泡排序
     * 第一轮：从第一个数开始，与其后邻接数比较，如果[j]>[j+1]，则交换两者，否则nothing，然后j++,此时[j]指向的值是之前两个数的最大值
     *      然后再重复上述比较，直到 j+1= n-1，即[n-2]和[n-1]的比较，此时不管谁大，结束后 n-1的值必然是整个数组中最大的
     * 第二轮：重复上述步骤，但这次的终点是 n-2, n-2是0~n-2中的最大值
     * .............
     * 最后一轮: 终点是 1, [0]和[1],[1]保存两者最大
     * 至此，冒泡排序结束，数组成功排序,  轮数 : n-1, 每轮比较数 实际上与直接交换排序一样多
     *
     * 也就是每轮，在j往前推进的过程中，泡泡(最大值)拖到当前指向位置，直到遇到顶
     * 这也意味着，每次交换必然使数朝着正确的方向前进，也为之后的每轮冒泡提供了方便
     * [对了，你也可以从最后一个数开始，将最小值拖到最前面来，都差不多 ]
     *
     *优化1：在每一轮结束后，如果不存在元素交换操作，可以认为，当前数组已经是排完序了
     *      因为 j从0~i-1过程中 如果任意两个相邻的数 [k]<[k+1], 并且 [i-1] < [i], 而[i+1]~[n-1]都是之前每轮得到的最大值
     *      此时数组已经排序完成， 可以在每轮开始时设置 isSwap = false，只有交换过才true，而每轮外循环增加 isSwap 判断
     *
     * 优化2： 这时不需要上面的优化1了
     *      在一轮的比较中，如果最后一次存在交换的位置是 k,即交换 k,k+1
     *      那么此时 K + 1 ~ n -1 都是有序的，即 k + 1 ~ n- 1已经保存了最后结果中的应有值
     *      而交换后的[k]不一定是0~k的最大值，因为之前只知道 [k] > [k+1](未交换前)
     *      那么下一轮只需要设置终点为 k, 不需比较后面的了
     *
     *      比优化2好些
     */
    int pos = n - 1;
    for (int i = n - 1; i >= 1; --i) { //一共 n-1轮, i其实也没太大意义，这里我这么写可以将 i 理解为每轮最大值的去向
        int last = -1; //每轮比较中最后发生交换的 j(j <--> j + 1)
        for (int j = 0; j < pos; ++j) { //每轮的终点（最大值要前往的地方）依次从n-1往前推进，直到 1
            if (a[j] > a[j + 1]) { //逆序对，无论是否交换，j+1保存0~j+1中的最大值
                swap(a, j, j + 1);
                last = j;
            }
        }
        if (last == -1) //不存在交换，说明数组已经排好序
            break;
        pos = last; //下一轮的终点为 pos
    }
}