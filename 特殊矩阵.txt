1. 矩阵的一维数组存储，假设 martix[M][N], list[M*N] 
	行优先：先将矩阵第一行保存，然后第二行..., matix[0][0]->list[0], matrix[0][2]->list[2]
		matrix[i][j] = list[ i * M + j ]
	列优先: 先从上到下保存第一列，然后第二列.... martix[1][0] = list[1], matrix[3][0] = list[3]
		matrix[i][j] = list[ J * N + i ]

2. 特殊矩阵的压缩存储
	（1）对称矩阵(此时 M = N)，即 matrix[i][j]= matrix[j][i], 很明显只需保存左上-右下对角线以及左/右侧的元素,（就像斜着切开）
		剩余元素: 第一行一个，第二行2个，....， 我们对左下侧部分进行按行存储的话, matrix[0][0] = list[0], matrix[1][0] = list[1], matrix[1][1]=list[2]..
		补充知识 ： 求 1 +   2   +   3   + ... + n 的和，如果你这样想象:
			       n  + n-1 + n-2 + ... + 1
		上下之和= n+1, 一共n个，所以共 (n+1)*n，然后取一半, (n+1)*n/2
		matirx[i][j]的位置，在 [i][0]之前一共有 1+2+3+..+i, 即 (i+1)* i / 2, 所以[i][j]的下标k = (i+1)*i / 2 + j
		当然这是 i >= j的下三角区域的计算，如果 j > i, 只需取[j][i]即可， 按列存储不多说

	(2)下/上三角矩阵(方阵), 即主对角线另一侧全是相同的值, 下三角矩阵即 martix[0][1]~[0][n-1] = c, [1][2]~[1][n-1]=c....
	 所以下三角区域还是按照上面的对称矩阵一样保存, 当 i < j时, [i][i] =c
	
	(3)三对角矩阵(方阵), 即 只有  martix[i][i-1], ,martix[i][i], martix[i][i+1] (0=<i<=n-1) 不是非零元素，其他元素都为0, 即[i][j], |i-j| > 1时,[i][j]=0
	
	当然第一行只有 martix[0][0],[0][1], 最后一行 [n-1][n-2],[n-1][n-1]
	对那斜向区域（非0）进行按行优先存储, 那么[i][i-1]之前, 有 2 + 3 + 3 + ..., 共(i-1)个3, 即 3 * i -1, 那么[i][i-1] 的 k = 3 * i - 1
	[i][i] = 3 * i,..., 所以[i][j] , k = 3 * i +  j - i

	(4)稀疏矩阵(方不方都行), 即只有极少数元素非0，其他都为0， 非零元素分布无规律
	那么单独保存每一个非0元素,  使用node{int row, int col, int value}保存在node数组中(无序)，但这样无法快速取[i][j]
	所以可以使用十字链表结构，node{int row, int col, int value, node *nextRow, node *nextCol}, 假如存在非零 [1][2], [3][2], [1][5]
	那么 假设 A = {1,2,?}, B = {3,2,?}, C = {1,5,?}
	原始ABC的相对位置为     A	C
		                       B
	那么 A.nextInRow = C, A.nextInCol = B,  即 nextInRow指向所在行中下一个非0元素，nextInCol指向所在列下一个非0元素
	这时我们可以分别有 node* rows[M], node* cols[N], 其中 rows[1] = A, row[3] = B, cols[2] = A, cols[5] = C, 即rows[i]指向[i][?]行中第一个非0元素, cols[j]保存[?][j]列中第一个非0
	当然每个元素都是节点保存，rows, cols只保存其地址
		
		

		
		