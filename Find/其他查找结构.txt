1. 伸展树
    基于局部性原理的二叉排序树
    即查找时如果查找到节点 X,那么就要通过左/右旋操作使X成为根节点
    如果没找到,那么还是把最后的查找节点移到根节点
    插入的话,先普通插入，然后移动到根节点
    一般每次操作都会进行splay操作

2. Treap
    二叉排序树与堆的结合
    在插入新节点的时候,会随机赋予newNode一个优先级(随机数),首先还是根据key将newNode插入到相应位置
    此时需要对树进行调整,我们定义任意节点的优先级必须小于其两个孩子节点, 那么就需要通过左右旋操作将newNode调整到优先级合适的位置
    核心还是二叉排序树，但额外根据priority构成小顶堆
    
3.跳跃表
   如果要保持你一个链表有序，我们在插入一个节点到有序链表中，需要从第一个元素开始比较，然后找到其应插入位置，最惨时须比较 n 次
   如果我们将链表中某些元素拿出来形成第二层索引，比如将 奇数 key元素作为第二层索引，插入newKey时，先与第二层索引进行比较找到一个范围i-j，然后再去第一层索引找到i，从i到j进行比较
   同样也可以对第二层索引建立第三层索引，一般插入新节点后，会采用掷硬币法，确定key是否加入第二层索引，如果加入，再掷硬币，key是否加入第三层索引，直到 false, 随机确定索引
   实际上第一层索引（原始链表）中的节点存在指针指向，其他层索引只保存节点在节点的地址（只保存key也行），而不是再生成一个节点
   
   见 ： https://www.jianshu.com/p/dc252b5efca6
    
4.B+ 树：不论是之前的二叉树还是B-树，数据都保存在节点中，以key查找到节点后，数据也一定保存在key相应节点中
   每个节点可以看成一个页，在一些磁盘IO操作中，读取一个页需要时间，如果一个页只保存几个数据，那效率太低了
   而B+数则可以解决，B+树中，非叶子节点只保存Key（索引值）, 并且node的孩子数与其key数相等（B-树是 keyNum = childNum-1）(有的定法定义都不同), 所以每个孩子节点对应一个父节点中的key，
   并且该Key会出现在相应孩子节点中，作为最大值/最小值，而叶子节点中才保存key和data，并且所有叶子节点，以一个链式结构连接起来，即叶子节点有一个指针指向下一个叶子节点（左->右）
   这时如果从左到右遍历叶子节点，那么所有数据都以key值有序输出，这么说我觉得挺难懂的
  
   根节点的孩子数大于2个
   我们设定父节点值在子节点中最大， 当然节点的 data1<data2<data3规则没有变
   struct node{data1, child1, data2,child2, data3,child3} 我们假设这是一个3-节点，假如child1是一个2-节点，那么2-节点中一定有data1,而另一个值<data1,同样对于child2,child3也是如此
   假设此时 child1是叶子，那么 child1所对应的node除了保存key值，还附带了相应的真正的data，而父节点中的data1也有数据在此
               例如：       7         10          15
                        1  5  7   --> 8 9 10  -->  11  13  15
               这里非叶子节点{7,10,15}只保存了key和child指针，而{1,5,7}节点对于每个key则保存了 key-value 数据项, 并且叶子节点是串联起来的，此时遍历可得 1,5,7,8,9,10,11,13,15
               这对于数据库的范围查找非常好用，假如查找 >=18 <40的数据，只需查找18的数据然后往后对叶子节点链表遍历直到40
   只有叶子节点是数据存储地方，其他非叶子只是起到了一个导航的作用，key值虽然重复存储，但对于真正保存的数据项相比不值一提，所以相对于B-数来说，一个页能保存更多数据
   
   查找过程基本差不多，节点的最后一个data是此子树中最大的，所以如果查找值大于last data,可断定查找值不存在
   在MySql中有两种索引：聚集索引和非聚集索引，他们都是B+树实现的，在聚集索引B+树中索引值是主键id,数据项是元组的其他列信息，而在非聚集索引中索引值是非主键,数据项是主键值
   也就是说如果我们用主键值去查找，搜索聚集索引树即可，如果我们使用非主键值查找，就需要再非聚集树中找到主键值，然后再去聚集索引中查找

   之前在网上搜索的博客讲解的B+树都是keyNum = childNum-1的树，我觉得很奇怪，但后面我发现keyNum=childNum的树实现起来好麻烦
   还不如沿用B-树的大概结构,当然此时某个子节点没有父节点中的一个元素，至于相关的内容自己去搜索
   
   如果按照维基百科的定义，实际上keyNum = childNum-1,并且不要求父节点元素一定存在与子节点
   具体操作见 ： https://www.cnblogs.com/nullzx/p/8729425.html

