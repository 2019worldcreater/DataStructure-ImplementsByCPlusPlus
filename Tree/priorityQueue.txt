 * 优先队列：
 *  在之前的队列中，都是先进先出，但优先队列不同，进队的元素都具有不同的优先级(与key不同)，而队列需要根据优先级的顺序进行出队
 *  一般有优先级大的先出（极大队列）或者优先级小的先出（极小队列）两种
 *
 *  实现数据结构为 堆，在堆排序中提到过
 *  大顶堆就是优先级大的先出队，小顶堆就是优先级小的先出队
 *  而堆的实现结构一般就是个一维顺序数组（堆的层序保存）
 *
    在堆中,只有根节点是最大/最小这点才能保证，其它的顺序无法保证

 *  构造大顶堆函数heapAdjust，在堆排序中已经编写了,而这就是主要操作逻辑
 *
 *  优先队列的出队： 删除根节点（数组第一个元素）,将堆中最后一个叶子节点(即数组的最后一个元素)放在根节点位置
        然后对根节点进行重构 --- 跟堆排序的过程基本一致
 *  优先队列的入队(大顶堆)： 插入节点直接放在数组最后一个元素，成为最后一个叶子节点（只有将最后的叶子节点放在根节点位置才不会影响其他子树的堆性质）
 *      然后node与其父节点的优先级进行比较，如果node.priority > parent.priority, 就交换 parent 和 node 位置, 然后再与node的新parent进行比较
 *      反复上述操作，直到没有父节点或者优先级<parent,此时停止，入队完成
 *
 * 至于为啥不直接对数组进行排序，没必要，浪费性能


 再提一个结构: 并查集, 其实就是一个数组保存元素，然后每个元素的只保存它的直接上级所在下标, 一个并查集其实就是森林的表示,里面一个group就是一棵树
 struct binNode{
    int parent;
    T data;
 }
 binNode p[MAX_SIZE];

 初始时，所有节点都是一棵树, parent=-1
 Find 操作：两元素是否为同一集合中,只需对两节点向上查找根节点即parent=-1的节点，然后比较根节点是否相同,相同则是一个集合
 Union 集合并操作： node1.root(node1节点所在树的根节点) = i, node2.root = j,  那么p[i].parent = j 或 j.parent = i

其实这跟在map中的最小生成树的kruscal算法的group数组原理类似
